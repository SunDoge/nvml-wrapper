/* automatically generated by rust-bindgen */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use std::os::raw;

pub const NVML_API_VERSION: raw::c_uint = 9;
pub const NVML_API_VERSION_STR: &'static [u8; 2usize] = b"9\x00";
pub const NVML_VALUE_NOT_AVAILABLE: raw::c_int = -1;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE: raw::c_uint = 32;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_V2_SIZE: raw::c_uint = 16;
pub const NVML_NVLINK_MAX_LINKS: raw::c_uint = 6;
pub const NVML_MAX_PHYSICAL_BRIDGE: raw::c_uint = 128;
pub const nvmlFlagDefault: raw::c_uint = 0;
pub const nvmlFlagForce: raw::c_uint = 1;
pub const NVML_FI_DEV_ECC_CURRENT: raw::c_uint = 1;
pub const NVML_FI_DEV_ECC_PENDING: raw::c_uint = 2;
pub const NVML_FI_DEV_ECC_SBE_VOL_TOTAL: raw::c_uint = 3;
pub const NVML_FI_DEV_ECC_DBE_VOL_TOTAL: raw::c_uint = 4;
pub const NVML_FI_DEV_ECC_SBE_AGG_TOTAL: raw::c_uint = 5;
pub const NVML_FI_DEV_ECC_DBE_AGG_TOTAL: raw::c_uint = 6;
pub const NVML_FI_DEV_ECC_SBE_VOL_L1: raw::c_uint = 7;
pub const NVML_FI_DEV_ECC_DBE_VOL_L1: raw::c_uint = 8;
pub const NVML_FI_DEV_ECC_SBE_VOL_L2: raw::c_uint = 9;
pub const NVML_FI_DEV_ECC_DBE_VOL_L2: raw::c_uint = 10;
pub const NVML_FI_DEV_ECC_SBE_VOL_DEV: raw::c_uint = 11;
pub const NVML_FI_DEV_ECC_DBE_VOL_DEV: raw::c_uint = 12;
pub const NVML_FI_DEV_ECC_SBE_VOL_REG: raw::c_uint = 13;
pub const NVML_FI_DEV_ECC_DBE_VOL_REG: raw::c_uint = 14;
pub const NVML_FI_DEV_ECC_SBE_VOL_TEX: raw::c_uint = 15;
pub const NVML_FI_DEV_ECC_DBE_VOL_TEX: raw::c_uint = 16;
pub const NVML_FI_DEV_ECC_DBE_VOL_CBU: raw::c_uint = 17;
pub const NVML_FI_DEV_ECC_SBE_AGG_L1: raw::c_uint = 18;
pub const NVML_FI_DEV_ECC_DBE_AGG_L1: raw::c_uint = 19;
pub const NVML_FI_DEV_ECC_SBE_AGG_L2: raw::c_uint = 20;
pub const NVML_FI_DEV_ECC_DBE_AGG_L2: raw::c_uint = 21;
pub const NVML_FI_DEV_ECC_SBE_AGG_DEV: raw::c_uint = 22;
pub const NVML_FI_DEV_ECC_DBE_AGG_DEV: raw::c_uint = 23;
pub const NVML_FI_DEV_ECC_SBE_AGG_REG: raw::c_uint = 24;
pub const NVML_FI_DEV_ECC_DBE_AGG_REG: raw::c_uint = 25;
pub const NVML_FI_DEV_ECC_SBE_AGG_TEX: raw::c_uint = 26;
pub const NVML_FI_DEV_ECC_DBE_AGG_TEX: raw::c_uint = 27;
pub const NVML_FI_DEV_ECC_DBE_AGG_CBU: raw::c_uint = 28;
pub const NVML_FI_DEV_RETIRED_SBE: raw::c_uint = 29;
pub const NVML_FI_DEV_RETIRED_DBE: raw::c_uint = 30;
pub const NVML_FI_DEV_RETIRED_PENDING: raw::c_uint = 31;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L0: raw::c_uint = 32;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L1: raw::c_uint = 33;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L2: raw::c_uint = 34;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L3: raw::c_uint = 35;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L4: raw::c_uint = 36;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L5: raw::c_uint = 37;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_TOTAL: raw::c_uint = 38;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L0: raw::c_uint = 39;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L1: raw::c_uint = 40;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L2: raw::c_uint = 41;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L3: raw::c_uint = 42;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L4: raw::c_uint = 43;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L5: raw::c_uint = 44;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_TOTAL: raw::c_uint = 45;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L0: raw::c_uint = 46;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L1: raw::c_uint = 47;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L2: raw::c_uint = 48;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L3: raw::c_uint = 49;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L4: raw::c_uint = 50;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L5: raw::c_uint = 51;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_TOTAL: raw::c_uint = 52;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L0: raw::c_uint = 53;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L1: raw::c_uint = 54;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L2: raw::c_uint = 55;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L3: raw::c_uint = 56;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L4: raw::c_uint = 57;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L5: raw::c_uint = 58;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_TOTAL: raw::c_uint = 59;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L0: raw::c_uint = 60;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L1: raw::c_uint = 61;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L2: raw::c_uint = 62;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L3: raw::c_uint = 63;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L4: raw::c_uint = 64;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L5: raw::c_uint = 65;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_TOTAL: raw::c_uint = 66;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L0: raw::c_uint = 67;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L1: raw::c_uint = 68;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L2: raw::c_uint = 69;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L3: raw::c_uint = 70;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L4: raw::c_uint = 71;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L5: raw::c_uint = 72;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_TOTAL: raw::c_uint = 73;
pub const NVML_FI_DEV_PERF_POLICY_POWER: raw::c_uint = 74;
pub const NVML_FI_DEV_PERF_POLICY_THERMAL: raw::c_uint = 75;
pub const NVML_FI_DEV_PERF_POLICY_SYNC_BOOST: raw::c_uint = 76;
pub const NVML_FI_DEV_PERF_POLICY_BOARD_LIMIT: raw::c_uint = 77;
pub const NVML_FI_DEV_PERF_POLICY_LOW_UTILIZATION: raw::c_uint = 78;
pub const NVML_FI_DEV_PERF_POLICY_RELIABILITY: raw::c_uint = 79;
pub const NVML_FI_DEV_PERF_POLICY_TOTAL_APP_CLOCKS: raw::c_uint = 80;
pub const NVML_FI_DEV_PERF_POLICY_TOTAL_BASE_CLOCKS: raw::c_uint = 81;
pub const NVML_FI_DEV_MEMORY_TEMP: raw::c_uint = 82;
pub const NVML_FI_DEV_TOTAL_ENERGY_CONSUMPTION: raw::c_uint = 83;
pub const NVML_FI_MAX: raw::c_uint = 84;
pub const nvmlEventTypeSingleBitEccError: raw::c_uint = 1;
pub const nvmlEventTypeDoubleBitEccError: raw::c_uint = 2;
pub const nvmlEventTypePState: raw::c_uint = 4;
pub const nvmlEventTypeXidCriticalError: raw::c_uint = 8;
pub const nvmlEventTypeClock: raw::c_uint = 16;
pub const nvmlEventTypeNone: raw::c_uint = 0;
pub const nvmlEventTypeAll: raw::c_uint = 31;
pub const nvmlClocksThrottleReasonGpuIdle: raw::c_uint = 1;
pub const nvmlClocksThrottleReasonApplicationsClocksSetting: raw::c_uint = 2;
pub const nvmlClocksThrottleReasonUserDefinedClocks: raw::c_uint = 2;
pub const nvmlClocksThrottleReasonSwPowerCap: raw::c_uint = 4;
pub const nvmlClocksThrottleReasonHwSlowdown: raw::c_uint = 8;
pub const nvmlClocksThrottleReasonSyncBoost: raw::c_uint = 16;
pub const nvmlClocksThrottleReasonSwThermalSlowdown: raw::c_uint = 32;
pub const nvmlClocksThrottleReasonNone: raw::c_uint = 0;
pub const NVML_GRID_LICENSE_BUFFER_SIZE: raw::c_uint = 128;
pub const NVML_VGPU_NAME_BUFFER_SIZE: raw::c_uint = 64;
pub const NVML_MAX_VGPU_TYPES_PER_PGPU: raw::c_uint = 17;
pub const NVML_MAX_VGPU_INSTANCES_PER_PGPU: raw::c_uint = 24;
pub const NVML_GRID_LICENSE_FEATURE_MAX_COUNT: raw::c_uint = 3;
pub const NVML_GRID_LICENSE_INFO_MAX_LENGTH: raw::c_uint = 128;
pub const NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE: raw::c_uint = 16;
pub const NVML_DEVICE_UUID_BUFFER_SIZE: raw::c_uint = 80;
pub const NVML_DEVICE_PART_NUMBER_BUFFER_SIZE: raw::c_uint = 80;
pub const NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE: raw::c_uint = 80;
pub const NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE: raw::c_uint = 80;
pub const NVML_DEVICE_NAME_BUFFER_SIZE: raw::c_uint = 64;
pub const NVML_DEVICE_SERIAL_BUFFER_SIZE: raw::c_uint = 30;
pub const NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE: raw::c_uint = 32;
#[repr(C)]
#[derive(Debug)]
pub struct nvmlDevice_st {
    _unused: [u8; 0],
}
pub type nvmlDevice_t = *mut nvmlDevice_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlPciInfo_st {
    pub busIdLegacy: [raw::c_char; 16usize],
    pub domain: raw::c_uint,
    pub bus: raw::c_uint,
    pub device: raw::c_uint,
    pub pciDeviceId: raw::c_uint,
    pub pciSubSystemId: raw::c_uint,
    pub busId: [raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_nvmlPciInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlPciInfo_st>() , 68usize , concat ! (
               "Size of: " , stringify ! ( nvmlPciInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlPciInfo_st>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nvmlPciInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . busIdLegacy as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( busIdLegacy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . domain as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . bus as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . device as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . pciDeviceId as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( pciDeviceId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . pciSubSystemId as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( pciSubSystemId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . busId as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( busId ) ));
}
impl Clone for nvmlPciInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlPciInfo_t = nvmlPciInfo_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlEccErrorCounts_st {
    pub l1Cache: raw::c_ulonglong,
    pub l2Cache: raw::c_ulonglong,
    pub deviceMemory: raw::c_ulonglong,
    pub registerFile: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlEccErrorCounts_st() {
    assert_eq!(::std::mem::size_of::<nvmlEccErrorCounts_st>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlEccErrorCounts_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlEccErrorCounts_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlEccErrorCounts_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEccErrorCounts_st ) ) . l1Cache as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEccErrorCounts_st )
                , "::" , stringify ! ( l1Cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEccErrorCounts_st ) ) . l2Cache as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEccErrorCounts_st )
                , "::" , stringify ! ( l2Cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEccErrorCounts_st ) ) . deviceMemory
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEccErrorCounts_st )
                , "::" , stringify ! ( deviceMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEccErrorCounts_st ) ) . registerFile
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEccErrorCounts_st )
                , "::" , stringify ! ( registerFile ) ));
}
impl Clone for nvmlEccErrorCounts_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlEccErrorCounts_t = nvmlEccErrorCounts_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlUtilization_st {
    pub gpu: raw::c_uint,
    pub memory: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlUtilization_st() {
    assert_eq!(::std::mem::size_of::<nvmlUtilization_st>() , 8usize , concat !
               ( "Size of: " , stringify ! ( nvmlUtilization_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlUtilization_st>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlUtilization_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUtilization_st ) ) . gpu as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUtilization_st ) ,
                "::" , stringify ! ( gpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUtilization_st ) ) . memory as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUtilization_st ) ,
                "::" , stringify ! ( memory ) ));
}
impl Clone for nvmlUtilization_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlUtilization_t = nvmlUtilization_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlMemory_st {
    pub total: raw::c_ulonglong,
    pub free: raw::c_ulonglong,
    pub used: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlMemory_st() {
    assert_eq!(::std::mem::size_of::<nvmlMemory_st>() , 24usize , concat ! (
               "Size of: " , stringify ! ( nvmlMemory_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlMemory_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nvmlMemory_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlMemory_st ) ) . total as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlMemory_st ) , "::"
                , stringify ! ( total ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlMemory_st ) ) . free as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlMemory_st ) , "::"
                , stringify ! ( free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlMemory_st ) ) . used as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlMemory_st ) , "::"
                , stringify ! ( used ) ));
}
impl Clone for nvmlMemory_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlMemory_t = nvmlMemory_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlBAR1Memory_st {
    pub bar1Total: raw::c_ulonglong,
    pub bar1Free: raw::c_ulonglong,
    pub bar1Used: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlBAR1Memory_st() {
    assert_eq!(::std::mem::size_of::<nvmlBAR1Memory_st>() , 24usize , concat !
               ( "Size of: " , stringify ! ( nvmlBAR1Memory_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlBAR1Memory_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlBAR1Memory_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBAR1Memory_st ) ) . bar1Total as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBAR1Memory_st ) ,
                "::" , stringify ! ( bar1Total ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBAR1Memory_st ) ) . bar1Free as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBAR1Memory_st ) ,
                "::" , stringify ! ( bar1Free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBAR1Memory_st ) ) . bar1Used as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBAR1Memory_st ) ,
                "::" , stringify ! ( bar1Used ) ));
}
impl Clone for nvmlBAR1Memory_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlBAR1Memory_t = nvmlBAR1Memory_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlProcessInfo_st {
    pub pid: raw::c_uint,
    pub usedGpuMemory: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlProcessInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlProcessInfo_st>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( nvmlProcessInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlProcessInfo_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlProcessInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlProcessInfo_st ) ) . pid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlProcessInfo_st ) ,
                "::" , stringify ! ( pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlProcessInfo_st ) ) . usedGpuMemory as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlProcessInfo_st ) ,
                "::" , stringify ! ( usedGpuMemory ) ));
}
impl Clone for nvmlProcessInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlProcessInfo_t = nvmlProcessInfo_st;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_PLX:
          nvmlBridgeChipType_enum =
    0;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_BRO4:
          nvmlBridgeChipType_enum =
    1;
pub type nvmlBridgeChipType_enum = raw::c_uint;
pub use self::nvmlBridgeChipType_enum as nvmlBridgeChipType_t;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_CYCLES:
          nvmlNvLinkUtilizationCountUnits_enum =
    0;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_PACKETS:
          nvmlNvLinkUtilizationCountUnits_enum =
    1;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_BYTES:
          nvmlNvLinkUtilizationCountUnits_enum =
    2;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_COUNT:
          nvmlNvLinkUtilizationCountUnits_enum =
    3;
pub type nvmlNvLinkUtilizationCountUnits_enum = raw::c_uint;
pub use self::nvmlNvLinkUtilizationCountUnits_enum as
        nvmlNvLinkUtilizationCountUnits_t;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NOP:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    1;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_READ:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    2;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_WRITE:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    4;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RATOM:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    8;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NRATOM:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    16;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_FLUSH:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    32;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    64;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    128;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_ALL:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    255;
pub type nvmlNvLinkUtilizationCountPktTypes_enum = raw::c_uint;
pub use self::nvmlNvLinkUtilizationCountPktTypes_enum as
        nvmlNvLinkUtilizationCountPktTypes_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlNvLinkUtilizationControl_st {
    pub units: nvmlNvLinkUtilizationCountUnits_t,
    pub pktfilter: nvmlNvLinkUtilizationCountPktTypes_t,
}
#[test]
fn bindgen_test_layout_nvmlNvLinkUtilizationControl_st() {
    assert_eq!(::std::mem::size_of::<nvmlNvLinkUtilizationControl_st>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( nvmlNvLinkUtilizationControl_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlNvLinkUtilizationControl_st>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                nvmlNvLinkUtilizationControl_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlNvLinkUtilizationControl_st ) ) .
                units as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlNvLinkUtilizationControl_st ) , "::" , stringify ! ( units
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlNvLinkUtilizationControl_st ) ) .
                pktfilter as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlNvLinkUtilizationControl_st ) , "::" , stringify ! (
                pktfilter ) ));
}
impl Clone for nvmlNvLinkUtilizationControl_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlNvLinkUtilizationControl_t = nvmlNvLinkUtilizationControl_st;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_SUPPORTED:
          nvmlNvLinkCapability_enum =
    0;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ACCESS:
          nvmlNvLinkCapability_enum =
    1;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_ATOMICS:
          nvmlNvLinkCapability_enum =
    2;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ATOMICS:
          nvmlNvLinkCapability_enum =
    3;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SLI_BRIDGE:
          nvmlNvLinkCapability_enum =
    4;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_VALID:
          nvmlNvLinkCapability_enum =
    5;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_COUNT:
          nvmlNvLinkCapability_enum =
    6;
pub type nvmlNvLinkCapability_enum = raw::c_uint;
pub use self::nvmlNvLinkCapability_enum as nvmlNvLinkCapability_t;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_REPLAY:
          nvmlNvLinkErrorCounter_enum =
    0;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_RECOVERY:
          nvmlNvLinkErrorCounter_enum =
    1;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_FLIT:
          nvmlNvLinkErrorCounter_enum =
    2;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_DATA:
          nvmlNvLinkErrorCounter_enum =
    3;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_COUNT:
          nvmlNvLinkErrorCounter_enum =
    4;
pub type nvmlNvLinkErrorCounter_enum = raw::c_uint;
pub use self::nvmlNvLinkErrorCounter_enum as nvmlNvLinkErrorCounter_t;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_INTERNAL: nvmlGpuLevel_enum = 0;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SINGLE: nvmlGpuLevel_enum = 10;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_MULTIPLE: nvmlGpuLevel_enum = 20;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_HOSTBRIDGE: nvmlGpuLevel_enum = 30;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_CPU: nvmlGpuLevel_enum = 40;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SYSTEM: nvmlGpuLevel_enum = 50;
pub type nvmlGpuLevel_enum = raw::c_uint;
pub use self::nvmlGpuLevel_enum as nvmlGpuTopologyLevel_t;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_OK: nvmlGpuP2PStatus_enum = 0;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED:
          nvmlGpuP2PStatus_enum =
    1;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_GPU_NOT_SUPPORTED:
          nvmlGpuP2PStatus_enum =
    2;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED:
          nvmlGpuP2PStatus_enum =
    3;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_DISABLED_BY_REGKEY:
          nvmlGpuP2PStatus_enum =
    4;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_NOT_SUPPORTED:
          nvmlGpuP2PStatus_enum =
    5;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_UNKNOWN: nvmlGpuP2PStatus_enum
          =
    6;
pub type nvmlGpuP2PStatus_enum = raw::c_uint;
pub use self::nvmlGpuP2PStatus_enum as nvmlGpuP2PStatus_t;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_READ:
          nvmlGpuP2PCapsIndex_enum =
    0;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_WRITE:
          nvmlGpuP2PCapsIndex_enum =
    1;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_NVLINK:
          nvmlGpuP2PCapsIndex_enum =
    2;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_ATOMICS:
          nvmlGpuP2PCapsIndex_enum =
    3;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_PROP:
          nvmlGpuP2PCapsIndex_enum =
    4;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_UNKNOWN:
          nvmlGpuP2PCapsIndex_enum =
    5;
pub type nvmlGpuP2PCapsIndex_enum = raw::c_uint;
pub use self::nvmlGpuP2PCapsIndex_enum as nvmlGpuP2PCapsIndex_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlBridgeChipInfo_st {
    pub type_: nvmlBridgeChipType_t,
    pub fwVersion: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlBridgeChipInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlBridgeChipInfo_st>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlBridgeChipInfo_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlBridgeChipInfo_st>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlBridgeChipInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBridgeChipInfo_st ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBridgeChipInfo_st )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBridgeChipInfo_st ) ) . fwVersion as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBridgeChipInfo_st )
                , "::" , stringify ! ( fwVersion ) ));
}
impl Clone for nvmlBridgeChipInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlBridgeChipInfo_t = nvmlBridgeChipInfo_st;
#[repr(C)]
pub struct nvmlBridgeChipHierarchy_st {
    pub bridgeCount: raw::c_uchar,
    pub bridgeChipInfo: [nvmlBridgeChipInfo_t; 128usize],
}
#[test]
fn bindgen_test_layout_nvmlBridgeChipHierarchy_st() {
    assert_eq!(::std::mem::size_of::<nvmlBridgeChipHierarchy_st>() , 1028usize
               , concat ! (
               "Size of: " , stringify ! ( nvmlBridgeChipHierarchy_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlBridgeChipHierarchy_st>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( nvmlBridgeChipHierarchy_st )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBridgeChipHierarchy_st ) ) .
                bridgeCount as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlBridgeChipHierarchy_st ) , "::" , stringify ! (
                bridgeCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBridgeChipHierarchy_st ) ) .
                bridgeChipInfo as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlBridgeChipHierarchy_st ) , "::" , stringify ! (
                bridgeChipInfo ) ));
}
pub type nvmlBridgeChipHierarchy_t = nvmlBridgeChipHierarchy_st;
pub const nvmlSamplingType_enum_NVML_TOTAL_POWER_SAMPLES:
          nvmlSamplingType_enum =
    0;
pub const nvmlSamplingType_enum_NVML_GPU_UTILIZATION_SAMPLES:
          nvmlSamplingType_enum =
    1;
pub const nvmlSamplingType_enum_NVML_MEMORY_UTILIZATION_SAMPLES:
          nvmlSamplingType_enum =
    2;
pub const nvmlSamplingType_enum_NVML_ENC_UTILIZATION_SAMPLES:
          nvmlSamplingType_enum =
    3;
pub const nvmlSamplingType_enum_NVML_DEC_UTILIZATION_SAMPLES:
          nvmlSamplingType_enum =
    4;
pub const nvmlSamplingType_enum_NVML_PROCESSOR_CLK_SAMPLES:
          nvmlSamplingType_enum =
    5;
pub const nvmlSamplingType_enum_NVML_MEMORY_CLK_SAMPLES: nvmlSamplingType_enum
          =
    6;
pub const nvmlSamplingType_enum_NVML_SAMPLINGTYPE_COUNT: nvmlSamplingType_enum
          =
    7;
pub type nvmlSamplingType_enum = raw::c_uint;
pub use self::nvmlSamplingType_enum as nvmlSamplingType_t;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_TX_BYTES:
          nvmlPcieUtilCounter_enum =
    0;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_RX_BYTES:
          nvmlPcieUtilCounter_enum =
    1;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_COUNT:
          nvmlPcieUtilCounter_enum =
    2;
pub type nvmlPcieUtilCounter_enum = raw::c_uint;
pub use self::nvmlPcieUtilCounter_enum as nvmlPcieUtilCounter_t;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_DOUBLE: nvmlValueType_enum = 0;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_INT: nvmlValueType_enum
          =
    1;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG: nvmlValueType_enum
          =
    2;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG_LONG:
          nvmlValueType_enum =
    3;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_SIGNED_LONG_LONG:
          nvmlValueType_enum =
    4;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_COUNT: nvmlValueType_enum = 5;
pub type nvmlValueType_enum = raw::c_uint;
pub use self::nvmlValueType_enum as nvmlValueType_t;
#[repr(C)]
#[derive(Copy)]
pub union nvmlValue_st {
    pub dVal: f64,
    pub uiVal: raw::c_uint,
    pub ulVal: raw::c_ulong,
    pub ullVal: raw::c_ulonglong,
    pub sllVal: raw::c_longlong,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_nvmlValue_st() {
    assert_eq!(::std::mem::size_of::<nvmlValue_st>() , 8usize , concat ! (
               "Size of: " , stringify ! ( nvmlValue_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlValue_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nvmlValue_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . dVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( dVal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . uiVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( uiVal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . ulVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( ulVal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . ullVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( ullVal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . sllVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( sllVal ) ));
}
impl Clone for nvmlValue_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlValue_t = nvmlValue_st;
#[repr(C)]
#[derive(Copy)]
pub struct nvmlSample_st {
    pub timeStamp: raw::c_ulonglong,
    pub sampleValue: nvmlValue_t,
}
#[test]
fn bindgen_test_layout_nvmlSample_st() {
    assert_eq!(::std::mem::size_of::<nvmlSample_st>() , 16usize , concat ! (
               "Size of: " , stringify ! ( nvmlSample_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlSample_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nvmlSample_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlSample_st ) ) . timeStamp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlSample_st ) , "::"
                , stringify ! ( timeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlSample_st ) ) . sampleValue as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlSample_st ) , "::"
                , stringify ! ( sampleValue ) ));
}
impl Clone for nvmlSample_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlSample_t = nvmlSample_st;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_POWER:
          nvmlPerfPolicyType_enum =
    0;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_THERMAL:
          nvmlPerfPolicyType_enum =
    1;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_SYNC_BOOST:
          nvmlPerfPolicyType_enum =
    2;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_BOARD_LIMIT:
          nvmlPerfPolicyType_enum =
    3;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_LOW_UTILIZATION:
          nvmlPerfPolicyType_enum =
    4;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_RELIABILITY:
          nvmlPerfPolicyType_enum =
    5;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_TOTAL_APP_CLOCKS:
          nvmlPerfPolicyType_enum =
    10;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_TOTAL_BASE_CLOCKS:
          nvmlPerfPolicyType_enum =
    11;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_COUNT:
          nvmlPerfPolicyType_enum =
    12;
pub type nvmlPerfPolicyType_enum = raw::c_uint;
pub use self::nvmlPerfPolicyType_enum as nvmlPerfPolicyType_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlViolationTime_st {
    pub referenceTime: raw::c_ulonglong,
    pub violationTime: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlViolationTime_st() {
    assert_eq!(::std::mem::size_of::<nvmlViolationTime_st>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlViolationTime_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlViolationTime_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlViolationTime_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlViolationTime_st ) ) . referenceTime
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlViolationTime_st )
                , "::" , stringify ! ( referenceTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlViolationTime_st ) ) . violationTime
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlViolationTime_st )
                , "::" , stringify ! ( violationTime ) ));
}
impl Clone for nvmlViolationTime_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlViolationTime_t = nvmlViolationTime_st;
pub const nvmlEnableState_enum_NVML_FEATURE_DISABLED: nvmlEnableState_enum =
    0;
pub const nvmlEnableState_enum_NVML_FEATURE_ENABLED: nvmlEnableState_enum = 1;
pub type nvmlEnableState_enum = raw::c_uint;
pub use self::nvmlEnableState_enum as nvmlEnableState_t;
pub const nvmlBrandType_enum_NVML_BRAND_UNKNOWN: nvmlBrandType_enum = 0;
pub const nvmlBrandType_enum_NVML_BRAND_QUADRO: nvmlBrandType_enum = 1;
pub const nvmlBrandType_enum_NVML_BRAND_TESLA: nvmlBrandType_enum = 2;
pub const nvmlBrandType_enum_NVML_BRAND_NVS: nvmlBrandType_enum = 3;
pub const nvmlBrandType_enum_NVML_BRAND_GRID: nvmlBrandType_enum = 4;
pub const nvmlBrandType_enum_NVML_BRAND_GEFORCE: nvmlBrandType_enum = 5;
pub const nvmlBrandType_enum_NVML_BRAND_COUNT: nvmlBrandType_enum = 6;
pub type nvmlBrandType_enum = raw::c_uint;
pub use self::nvmlBrandType_enum as nvmlBrandType_t;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SHUTDOWN:
          nvmlTemperatureThresholds_enum =
    0;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SLOWDOWN:
          nvmlTemperatureThresholds_enum =
    1;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_MEM_MAX:
          nvmlTemperatureThresholds_enum =
    2;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_GPU_MAX:
          nvmlTemperatureThresholds_enum =
    3;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_COUNT:
          nvmlTemperatureThresholds_enum =
    4;
pub type nvmlTemperatureThresholds_enum = raw::c_uint;
pub use self::nvmlTemperatureThresholds_enum as nvmlTemperatureThresholds_t;
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_GPU:
          nvmlTemperatureSensors_enum =
    0;
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_COUNT:
          nvmlTemperatureSensors_enum =
    1;
pub type nvmlTemperatureSensors_enum = raw::c_uint;
pub use self::nvmlTemperatureSensors_enum as nvmlTemperatureSensors_t;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_DEFAULT: nvmlComputeMode_enum
          =
    0;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_THREAD:
          nvmlComputeMode_enum =
    1;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_PROHIBITED:
          nvmlComputeMode_enum =
    2;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_PROCESS:
          nvmlComputeMode_enum =
    3;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_COUNT: nvmlComputeMode_enum =
    4;
pub type nvmlComputeMode_enum = raw::c_uint;
pub use self::nvmlComputeMode_enum as nvmlComputeMode_t;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_CORRECTED:
          nvmlMemoryErrorType_enum =
    0;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_UNCORRECTED:
          nvmlMemoryErrorType_enum =
    1;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_COUNT:
          nvmlMemoryErrorType_enum =
    2;
pub type nvmlMemoryErrorType_enum = raw::c_uint;
pub use self::nvmlMemoryErrorType_enum as nvmlMemoryErrorType_t;
pub const nvmlEccCounterType_enum_NVML_VOLATILE_ECC: nvmlEccCounterType_enum =
    0;
pub const nvmlEccCounterType_enum_NVML_AGGREGATE_ECC: nvmlEccCounterType_enum
          =
    1;
pub const nvmlEccCounterType_enum_NVML_ECC_COUNTER_TYPE_COUNT:
          nvmlEccCounterType_enum =
    2;
pub type nvmlEccCounterType_enum = raw::c_uint;
pub use self::nvmlEccCounterType_enum as nvmlEccCounterType_t;
pub const nvmlClockType_enum_NVML_CLOCK_GRAPHICS: nvmlClockType_enum = 0;
pub const nvmlClockType_enum_NVML_CLOCK_SM: nvmlClockType_enum = 1;
pub const nvmlClockType_enum_NVML_CLOCK_MEM: nvmlClockType_enum = 2;
pub const nvmlClockType_enum_NVML_CLOCK_VIDEO: nvmlClockType_enum = 3;
pub const nvmlClockType_enum_NVML_CLOCK_COUNT: nvmlClockType_enum = 4;
pub type nvmlClockType_enum = raw::c_uint;
pub use self::nvmlClockType_enum as nvmlClockType_t;
pub const nvmlClockId_enum_NVML_CLOCK_ID_CURRENT: nvmlClockId_enum = 0;
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_TARGET: nvmlClockId_enum =
    1;
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_DEFAULT: nvmlClockId_enum =
    2;
pub const nvmlClockId_enum_NVML_CLOCK_ID_CUSTOMER_BOOST_MAX: nvmlClockId_enum
          =
    3;
pub const nvmlClockId_enum_NVML_CLOCK_ID_COUNT: nvmlClockId_enum = 4;
pub type nvmlClockId_enum = raw::c_uint;
pub use self::nvmlClockId_enum as nvmlClockId_t;
pub const nvmlDriverModel_enum_NVML_DRIVER_WDDM: nvmlDriverModel_enum = 0;
pub const nvmlDriverModel_enum_NVML_DRIVER_WDM: nvmlDriverModel_enum = 1;
pub type nvmlDriverModel_enum = raw::c_uint;
pub use self::nvmlDriverModel_enum as nvmlDriverModel_t;
pub const nvmlPStates_enum_NVML_PSTATE_0: nvmlPStates_enum = 0;
pub const nvmlPStates_enum_NVML_PSTATE_1: nvmlPStates_enum = 1;
pub const nvmlPStates_enum_NVML_PSTATE_2: nvmlPStates_enum = 2;
pub const nvmlPStates_enum_NVML_PSTATE_3: nvmlPStates_enum = 3;
pub const nvmlPStates_enum_NVML_PSTATE_4: nvmlPStates_enum = 4;
pub const nvmlPStates_enum_NVML_PSTATE_5: nvmlPStates_enum = 5;
pub const nvmlPStates_enum_NVML_PSTATE_6: nvmlPStates_enum = 6;
pub const nvmlPStates_enum_NVML_PSTATE_7: nvmlPStates_enum = 7;
pub const nvmlPStates_enum_NVML_PSTATE_8: nvmlPStates_enum = 8;
pub const nvmlPStates_enum_NVML_PSTATE_9: nvmlPStates_enum = 9;
pub const nvmlPStates_enum_NVML_PSTATE_10: nvmlPStates_enum = 10;
pub const nvmlPStates_enum_NVML_PSTATE_11: nvmlPStates_enum = 11;
pub const nvmlPStates_enum_NVML_PSTATE_12: nvmlPStates_enum = 12;
pub const nvmlPStates_enum_NVML_PSTATE_13: nvmlPStates_enum = 13;
pub const nvmlPStates_enum_NVML_PSTATE_14: nvmlPStates_enum = 14;
pub const nvmlPStates_enum_NVML_PSTATE_15: nvmlPStates_enum = 15;
pub const nvmlPStates_enum_NVML_PSTATE_UNKNOWN: nvmlPStates_enum = 32;
pub type nvmlPStates_enum = raw::c_uint;
pub use self::nvmlPStates_enum as nvmlPstates_t;
pub const nvmlGom_enum_NVML_GOM_ALL_ON: nvmlGom_enum = 0;
pub const nvmlGom_enum_NVML_GOM_COMPUTE: nvmlGom_enum = 1;
pub const nvmlGom_enum_NVML_GOM_LOW_DP: nvmlGom_enum = 2;
pub type nvmlGom_enum = raw::c_uint;
pub use self::nvmlGom_enum as nvmlGpuOperationMode_t;
pub const nvmlInforomObject_enum_NVML_INFOROM_OEM: nvmlInforomObject_enum = 0;
pub const nvmlInforomObject_enum_NVML_INFOROM_ECC: nvmlInforomObject_enum = 1;
pub const nvmlInforomObject_enum_NVML_INFOROM_POWER: nvmlInforomObject_enum =
    2;
pub const nvmlInforomObject_enum_NVML_INFOROM_COUNT: nvmlInforomObject_enum =
    3;
pub type nvmlInforomObject_enum = raw::c_uint;
pub use self::nvmlInforomObject_enum as nvmlInforomObject_t;
pub const nvmlReturn_enum_NVML_SUCCESS: nvmlReturn_enum = 0;
pub const nvmlReturn_enum_NVML_ERROR_UNINITIALIZED: nvmlReturn_enum = 1;
pub const nvmlReturn_enum_NVML_ERROR_INVALID_ARGUMENT: nvmlReturn_enum = 2;
pub const nvmlReturn_enum_NVML_ERROR_NOT_SUPPORTED: nvmlReturn_enum = 3;
pub const nvmlReturn_enum_NVML_ERROR_NO_PERMISSION: nvmlReturn_enum = 4;
pub const nvmlReturn_enum_NVML_ERROR_ALREADY_INITIALIZED: nvmlReturn_enum = 5;
pub const nvmlReturn_enum_NVML_ERROR_NOT_FOUND: nvmlReturn_enum = 6;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_SIZE: nvmlReturn_enum = 7;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_POWER: nvmlReturn_enum = 8;
pub const nvmlReturn_enum_NVML_ERROR_DRIVER_NOT_LOADED: nvmlReturn_enum = 9;
pub const nvmlReturn_enum_NVML_ERROR_TIMEOUT: nvmlReturn_enum = 10;
pub const nvmlReturn_enum_NVML_ERROR_IRQ_ISSUE: nvmlReturn_enum = 11;
pub const nvmlReturn_enum_NVML_ERROR_LIBRARY_NOT_FOUND: nvmlReturn_enum = 12;
pub const nvmlReturn_enum_NVML_ERROR_FUNCTION_NOT_FOUND: nvmlReturn_enum = 13;
pub const nvmlReturn_enum_NVML_ERROR_CORRUPTED_INFOROM: nvmlReturn_enum = 14;
pub const nvmlReturn_enum_NVML_ERROR_GPU_IS_LOST: nvmlReturn_enum = 15;
pub const nvmlReturn_enum_NVML_ERROR_RESET_REQUIRED: nvmlReturn_enum = 16;
pub const nvmlReturn_enum_NVML_ERROR_OPERATING_SYSTEM: nvmlReturn_enum = 17;
pub const nvmlReturn_enum_NVML_ERROR_LIB_RM_VERSION_MISMATCH: nvmlReturn_enum
          =
    18;
pub const nvmlReturn_enum_NVML_ERROR_IN_USE: nvmlReturn_enum = 19;
pub const nvmlReturn_enum_NVML_ERROR_MEMORY: nvmlReturn_enum = 20;
pub const nvmlReturn_enum_NVML_ERROR_NO_DATA: nvmlReturn_enum = 21;
pub const nvmlReturn_enum_NVML_ERROR_VGPU_ECC_NOT_SUPPORTED: nvmlReturn_enum =
    22;
pub const nvmlReturn_enum_NVML_ERROR_UNKNOWN: nvmlReturn_enum = 999;
pub type nvmlReturn_enum = raw::c_uint;
pub use self::nvmlReturn_enum as nvmlReturn_t;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L1_CACHE:
          nvmlMemoryLocation_enum =
    0;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L2_CACHE:
          nvmlMemoryLocation_enum =
    1;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_DEVICE_MEMORY:
          nvmlMemoryLocation_enum =
    2;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_REGISTER_FILE:
          nvmlMemoryLocation_enum =
    3;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_MEMORY:
          nvmlMemoryLocation_enum =
    4;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_SHM:
          nvmlMemoryLocation_enum =
    5;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_CBU:
          nvmlMemoryLocation_enum =
    6;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_COUNT:
          nvmlMemoryLocation_enum =
    7;
pub type nvmlMemoryLocation_enum = raw::c_uint;
pub use self::nvmlMemoryLocation_enum as nvmlMemoryLocation_t;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS:
          nvmlPageRetirementCause_enum =
    0;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR:
          nvmlPageRetirementCause_enum =
    1;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_COUNT:
          nvmlPageRetirementCause_enum =
    2;
pub type nvmlPageRetirementCause_enum = raw::c_uint;
pub use self::nvmlPageRetirementCause_enum as nvmlPageRetirementCause_t;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS:
          nvmlRestrictedAPI_enum =
    0;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS:
          nvmlRestrictedAPI_enum =
    1;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_COUNT:
          nvmlRestrictedAPI_enum =
    2;
pub type nvmlRestrictedAPI_enum = raw::c_uint;
pub use self::nvmlRestrictedAPI_enum as nvmlRestrictedAPI_t;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_NONE:
          nvmlGpuVirtualizationMode =
    0;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_PASSTHROUGH:
          nvmlGpuVirtualizationMode =
    1;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_VGPU:
          nvmlGpuVirtualizationMode =
    2;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_HOST_VGPU:
          nvmlGpuVirtualizationMode =
    3;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_HOST_VSGA:
          nvmlGpuVirtualizationMode =
    4;
pub type nvmlGpuVirtualizationMode = raw::c_uint;
pub use self::nvmlGpuVirtualizationMode as nvmlGpuVirtualizationMode_t;
#[repr(C)]
#[derive(Copy)]
pub struct nvmlFieldValue_st {
    pub fieldId: raw::c_uint,
    pub unused: raw::c_uint,
    pub timestamp: raw::c_longlong,
    pub latencyUsec: raw::c_longlong,
    pub valueType: nvmlValueType_t,
    pub nvmlReturn: nvmlReturn_t,
    pub value: nvmlValue_t,
}
#[test]
fn bindgen_test_layout_nvmlFieldValue_st() {
    assert_eq!(::std::mem::size_of::<nvmlFieldValue_st>() , 40usize , concat !
               ( "Size of: " , stringify ! ( nvmlFieldValue_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlFieldValue_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlFieldValue_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlFieldValue_st ) ) . fieldId as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlFieldValue_st ) ,
                "::" , stringify ! ( fieldId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlFieldValue_st ) ) . unused as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlFieldValue_st ) ,
                "::" , stringify ! ( unused ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlFieldValue_st ) ) . timestamp as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlFieldValue_st ) ,
                "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlFieldValue_st ) ) . latencyUsec as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlFieldValue_st ) ,
                "::" , stringify ! ( latencyUsec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlFieldValue_st ) ) . valueType as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlFieldValue_st ) ,
                "::" , stringify ! ( valueType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlFieldValue_st ) ) . nvmlReturn as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlFieldValue_st ) ,
                "::" , stringify ! ( nvmlReturn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlFieldValue_st ) ) . value as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlFieldValue_st ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for nvmlFieldValue_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlFieldValue_t = nvmlFieldValue_st;
#[repr(C)]
#[derive(Debug)]
pub struct nvmlUnit_st {
    _unused: [u8; 0],
}
pub type nvmlUnit_t = *mut nvmlUnit_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlHwbcEntry_st {
    pub hwbcId: raw::c_uint,
    pub firmwareVersion: [raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_nvmlHwbcEntry_st() {
    assert_eq!(::std::mem::size_of::<nvmlHwbcEntry_st>() , 36usize , concat !
               ( "Size of: " , stringify ! ( nvmlHwbcEntry_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlHwbcEntry_st>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( nvmlHwbcEntry_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlHwbcEntry_st ) ) . hwbcId as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlHwbcEntry_st ) ,
                "::" , stringify ! ( hwbcId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlHwbcEntry_st ) ) . firmwareVersion as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlHwbcEntry_st ) ,
                "::" , stringify ! ( firmwareVersion ) ));
}
impl Clone for nvmlHwbcEntry_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlHwbcEntry_t = nvmlHwbcEntry_st;
pub const nvmlFanState_enum_NVML_FAN_NORMAL: nvmlFanState_enum = 0;
pub const nvmlFanState_enum_NVML_FAN_FAILED: nvmlFanState_enum = 1;
pub type nvmlFanState_enum = raw::c_uint;
pub use self::nvmlFanState_enum as nvmlFanState_t;
pub const nvmlLedColor_enum_NVML_LED_COLOR_GREEN: nvmlLedColor_enum = 0;
pub const nvmlLedColor_enum_NVML_LED_COLOR_AMBER: nvmlLedColor_enum = 1;
pub type nvmlLedColor_enum = raw::c_uint;
pub use self::nvmlLedColor_enum as nvmlLedColor_t;
#[repr(C)]
#[derive(Copy)]
pub struct nvmlLedState_st {
    pub cause: [raw::c_char; 256usize],
    pub color: nvmlLedColor_t,
}
#[test]
fn bindgen_test_layout_nvmlLedState_st() {
    assert_eq!(::std::mem::size_of::<nvmlLedState_st>() , 260usize , concat !
               ( "Size of: " , stringify ! ( nvmlLedState_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlLedState_st>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( nvmlLedState_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlLedState_st ) ) . cause as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlLedState_st ) ,
                "::" , stringify ! ( cause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlLedState_st ) ) . color as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlLedState_st ) ,
                "::" , stringify ! ( color ) ));
}
impl Clone for nvmlLedState_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlLedState_t = nvmlLedState_st;
#[repr(C)]
#[derive(Copy)]
pub struct nvmlUnitInfo_st {
    pub name: [raw::c_char; 96usize],
    pub id: [raw::c_char; 96usize],
    pub serial: [raw::c_char; 96usize],
    pub firmwareVersion: [raw::c_char; 96usize],
}
#[test]
fn bindgen_test_layout_nvmlUnitInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlUnitInfo_st>() , 384usize , concat !
               ( "Size of: " , stringify ! ( nvmlUnitInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlUnitInfo_st>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( nvmlUnitInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitInfo_st ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitInfo_st ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitInfo_st ) ) . id as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitInfo_st ) ,
                "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitInfo_st ) ) . serial as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitInfo_st ) ,
                "::" , stringify ! ( serial ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitInfo_st ) ) . firmwareVersion as
                * const _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitInfo_st ) ,
                "::" , stringify ! ( firmwareVersion ) ));
}
impl Clone for nvmlUnitInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlUnitInfo_t = nvmlUnitInfo_st;
#[repr(C)]
#[derive(Copy)]
pub struct nvmlPSUInfo_st {
    pub state: [raw::c_char; 256usize],
    pub current: raw::c_uint,
    pub voltage: raw::c_uint,
    pub power: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlPSUInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlPSUInfo_st>() , 268usize , concat ! (
               "Size of: " , stringify ! ( nvmlPSUInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlPSUInfo_st>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nvmlPSUInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPSUInfo_st ) ) . state as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPSUInfo_st ) , "::"
                , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPSUInfo_st ) ) . current as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPSUInfo_st ) , "::"
                , stringify ! ( current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPSUInfo_st ) ) . voltage as * const _
                as usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPSUInfo_st ) , "::"
                , stringify ! ( voltage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPSUInfo_st ) ) . power as * const _
                as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPSUInfo_st ) , "::"
                , stringify ! ( power ) ));
}
impl Clone for nvmlPSUInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlPSUInfo_t = nvmlPSUInfo_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlUnitFanInfo_st {
    pub speed: raw::c_uint,
    pub state: nvmlFanState_t,
}
#[test]
fn bindgen_test_layout_nvmlUnitFanInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlUnitFanInfo_st>() , 8usize , concat !
               ( "Size of: " , stringify ! ( nvmlUnitFanInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlUnitFanInfo_st>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlUnitFanInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitFanInfo_st ) ) . speed as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitFanInfo_st ) ,
                "::" , stringify ! ( speed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitFanInfo_st ) ) . state as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitFanInfo_st ) ,
                "::" , stringify ! ( state ) ));
}
impl Clone for nvmlUnitFanInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlUnitFanInfo_t = nvmlUnitFanInfo_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlUnitFanSpeeds_st {
    pub fans: [nvmlUnitFanInfo_t; 24usize],
    pub count: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlUnitFanSpeeds_st() {
    assert_eq!(::std::mem::size_of::<nvmlUnitFanSpeeds_st>() , 196usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlUnitFanSpeeds_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlUnitFanSpeeds_st>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlUnitFanSpeeds_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitFanSpeeds_st ) ) . fans as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitFanSpeeds_st )
                , "::" , stringify ! ( fans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitFanSpeeds_st ) ) . count as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitFanSpeeds_st )
                , "::" , stringify ! ( count ) ));
}
impl Clone for nvmlUnitFanSpeeds_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlUnitFanSpeeds_t = nvmlUnitFanSpeeds_st;
#[repr(C)]
#[derive(Debug)]
pub struct nvmlEventSet_st {
    _unused: [u8; 0],
}
pub type nvmlEventSet_t = *mut nvmlEventSet_st;
#[repr(C)]
#[derive(Debug)]
pub struct nvmlEventData_st {
    pub device: nvmlDevice_t,
    pub eventType: raw::c_ulonglong,
    pub eventData: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlEventData_st() {
    assert_eq!(::std::mem::size_of::<nvmlEventData_st>() , 24usize , concat !
               ( "Size of: " , stringify ! ( nvmlEventData_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlEventData_st>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nvmlEventData_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEventData_st ) ) . device as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEventData_st ) ,
                "::" , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEventData_st ) ) . eventType as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEventData_st ) ,
                "::" , stringify ! ( eventType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEventData_st ) ) . eventData as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEventData_st ) ,
                "::" , stringify ! ( eventData ) ));
}
pub type nvmlEventData_t = nvmlEventData_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlAccountingStats_st {
    pub gpuUtilization: raw::c_uint,
    pub memoryUtilization: raw::c_uint,
    pub maxMemoryUsage: raw::c_ulonglong,
    pub time: raw::c_ulonglong,
    pub startTime: raw::c_ulonglong,
    pub isRunning: raw::c_uint,
    pub reserved: [raw::c_uint; 5usize],
}
#[test]
fn bindgen_test_layout_nvmlAccountingStats_st() {
    assert_eq!(::std::mem::size_of::<nvmlAccountingStats_st>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlAccountingStats_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlAccountingStats_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlAccountingStats_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) .
                gpuUtilization as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( gpuUtilization ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) .
                memoryUtilization as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( memoryUtilization ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) .
                maxMemoryUsage as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( maxMemoryUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) . time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) . startTime as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( startTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) . isRunning as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( isRunning ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) . reserved as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( reserved ) ));
}
impl Clone for nvmlAccountingStats_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlAccountingStats_t = nvmlAccountingStats_st;
pub const nvmlVgpuVmIdType_NVML_VGPU_VM_ID_DOMAIN_ID: nvmlVgpuVmIdType = 0;
pub const nvmlVgpuVmIdType_NVML_VGPU_VM_ID_UUID: nvmlVgpuVmIdType = 1;
pub type nvmlVgpuVmIdType = raw::c_uint;
pub use self::nvmlVgpuVmIdType as nvmlVgpuVmIdType_t;
pub const nvmlVgpuGuestInfoState_enum_NVML_VGPU_INSTANCE_GUEST_INFO_STATE_UNINITIALIZED:
          nvmlVgpuGuestInfoState_enum =
    0;
pub const nvmlVgpuGuestInfoState_enum_NVML_VGPU_INSTANCE_GUEST_INFO_STATE_INITIALIZED:
          nvmlVgpuGuestInfoState_enum =
    1;
pub type nvmlVgpuGuestInfoState_enum = raw::c_uint;
pub use self::nvmlVgpuGuestInfoState_enum as nvmlVgpuGuestInfoState_t;
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_VGPU:
          nvmlGridLicenseFeatureCode_t =
    1;
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_VWORKSTATION:
          nvmlGridLicenseFeatureCode_t =
    2;
pub type nvmlGridLicenseFeatureCode_t = raw::c_uint;
pub type nvmlVgpuTypeId_t = raw::c_uint;
pub type nvmlVgpuInstance_t = raw::c_uint;
#[repr(C)]
#[derive(Copy)]
pub struct nvmlVgpuInstanceUtilizationSample_st {
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub timeStamp: raw::c_ulonglong,
    pub smUtil: nvmlValue_t,
    pub memUtil: nvmlValue_t,
    pub encUtil: nvmlValue_t,
    pub decUtil: nvmlValue_t,
}
#[test]
fn bindgen_test_layout_nvmlVgpuInstanceUtilizationSample_st() {
    assert_eq!(::std::mem::size_of::<nvmlVgpuInstanceUtilizationSample_st>() ,
               48usize , concat ! (
               "Size of: " , stringify ! (
               nvmlVgpuInstanceUtilizationSample_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlVgpuInstanceUtilizationSample_st>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                nvmlVgpuInstanceUtilizationSample_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuInstanceUtilizationSample_st ) )
                . vgpuInstance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuInstanceUtilizationSample_st ) , "::" , stringify ! (
                vgpuInstance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuInstanceUtilizationSample_st ) )
                . timeStamp as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuInstanceUtilizationSample_st ) , "::" , stringify ! (
                timeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuInstanceUtilizationSample_st ) )
                . smUtil as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuInstanceUtilizationSample_st ) , "::" , stringify ! (
                smUtil ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuInstanceUtilizationSample_st ) )
                . memUtil as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuInstanceUtilizationSample_st ) , "::" , stringify ! (
                memUtil ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuInstanceUtilizationSample_st ) )
                . encUtil as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuInstanceUtilizationSample_st ) , "::" , stringify ! (
                encUtil ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuInstanceUtilizationSample_st ) )
                . decUtil as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuInstanceUtilizationSample_st ) , "::" , stringify ! (
                decUtil ) ));
}
impl Clone for nvmlVgpuInstanceUtilizationSample_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlVgpuInstanceUtilizationSample_t =
    nvmlVgpuInstanceUtilizationSample_st;
#[repr(C)]
#[derive(Copy)]
pub struct nvmlVgpuProcessUtilizationSample_st {
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub pid: raw::c_uint,
    pub processName: [raw::c_char; 64usize],
    pub timeStamp: raw::c_ulonglong,
    pub smUtil: raw::c_uint,
    pub memUtil: raw::c_uint,
    pub encUtil: raw::c_uint,
    pub decUtil: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlVgpuProcessUtilizationSample_st() {
    assert_eq!(::std::mem::size_of::<nvmlVgpuProcessUtilizationSample_st>() ,
               96usize , concat ! (
               "Size of: " , stringify ! ( nvmlVgpuProcessUtilizationSample_st
               ) ));
    assert_eq! (::std::mem::align_of::<nvmlVgpuProcessUtilizationSample_st>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                nvmlVgpuProcessUtilizationSample_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuProcessUtilizationSample_st ) ) .
                vgpuInstance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuProcessUtilizationSample_st ) , "::" , stringify ! (
                vgpuInstance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuProcessUtilizationSample_st ) ) .
                pid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuProcessUtilizationSample_st ) , "::" , stringify ! (
                pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuProcessUtilizationSample_st ) ) .
                processName as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuProcessUtilizationSample_st ) , "::" , stringify ! (
                processName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuProcessUtilizationSample_st ) ) .
                timeStamp as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuProcessUtilizationSample_st ) , "::" , stringify ! (
                timeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuProcessUtilizationSample_st ) ) .
                smUtil as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuProcessUtilizationSample_st ) , "::" , stringify ! (
                smUtil ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuProcessUtilizationSample_st ) ) .
                memUtil as * const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuProcessUtilizationSample_st ) , "::" , stringify ! (
                memUtil ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuProcessUtilizationSample_st ) ) .
                encUtil as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuProcessUtilizationSample_st ) , "::" , stringify ! (
                encUtil ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlVgpuProcessUtilizationSample_st ) ) .
                decUtil as * const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlVgpuProcessUtilizationSample_st ) , "::" , stringify ! (
                decUtil ) ));
}
impl Clone for nvmlVgpuProcessUtilizationSample_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlVgpuProcessUtilizationSample_t =
    nvmlVgpuProcessUtilizationSample_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlProcessUtilizationSample_st {
    pub pid: raw::c_uint,
    pub timeStamp: raw::c_ulonglong,
    pub smUtil: raw::c_uint,
    pub memUtil: raw::c_uint,
    pub encUtil: raw::c_uint,
    pub decUtil: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlProcessUtilizationSample_st() {
    assert_eq!(::std::mem::size_of::<nvmlProcessUtilizationSample_st>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( nvmlProcessUtilizationSample_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlProcessUtilizationSample_st>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                nvmlProcessUtilizationSample_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlProcessUtilizationSample_st ) ) . pid
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlProcessUtilizationSample_st ) , "::" , stringify ! ( pid )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlProcessUtilizationSample_st ) ) .
                timeStamp as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlProcessUtilizationSample_st ) , "::" , stringify ! (
                timeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlProcessUtilizationSample_st ) ) .
                smUtil as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlProcessUtilizationSample_st ) , "::" , stringify ! (
                smUtil ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlProcessUtilizationSample_st ) ) .
                memUtil as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlProcessUtilizationSample_st ) , "::" , stringify ! (
                memUtil ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlProcessUtilizationSample_st ) ) .
                encUtil as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlProcessUtilizationSample_st ) , "::" , stringify ! (
                encUtil ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlProcessUtilizationSample_st ) ) .
                decUtil as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlProcessUtilizationSample_st ) , "::" , stringify ! (
                decUtil ) ));
}
impl Clone for nvmlProcessUtilizationSample_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlProcessUtilizationSample_t = nvmlProcessUtilizationSample_st;
#[repr(C)]
#[derive(Copy)]
pub struct nvmlGridLicensableFeature_st {
    pub featureCode: nvmlGridLicenseFeatureCode_t,
    pub featureState: raw::c_uint,
    pub licenseInfo: [raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_nvmlGridLicensableFeature_st() {
    assert_eq!(::std::mem::size_of::<nvmlGridLicensableFeature_st>() ,
               136usize , concat ! (
               "Size of: " , stringify ! ( nvmlGridLicensableFeature_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlGridLicensableFeature_st>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( nvmlGridLicensableFeature_st )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlGridLicensableFeature_st ) ) .
                featureCode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlGridLicensableFeature_st ) , "::" , stringify ! (
                featureCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlGridLicensableFeature_st ) ) .
                featureState as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlGridLicensableFeature_st ) , "::" , stringify ! (
                featureState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlGridLicensableFeature_st ) ) .
                licenseInfo as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlGridLicensableFeature_st ) , "::" , stringify ! (
                licenseInfo ) ));
}
impl Clone for nvmlGridLicensableFeature_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlGridLicensableFeature_t = nvmlGridLicensableFeature_st;
#[repr(C)]
#[derive(Copy)]
pub struct nvmlGridLicensableFeatures_st {
    pub isGridLicenseSupported: raw::c_int,
    pub licensableFeaturesCount: raw::c_uint,
    pub gridLicensableFeatures: [nvmlGridLicensableFeature_t; 3usize],
}
#[test]
fn bindgen_test_layout_nvmlGridLicensableFeatures_st() {
    assert_eq!(::std::mem::size_of::<nvmlGridLicensableFeatures_st>() ,
               416usize , concat ! (
               "Size of: " , stringify ! ( nvmlGridLicensableFeatures_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlGridLicensableFeatures_st>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( nvmlGridLicensableFeatures_st
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlGridLicensableFeatures_st ) ) .
                isGridLicenseSupported as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                nvmlGridLicensableFeatures_st ) , "::" , stringify ! (
                isGridLicenseSupported ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlGridLicensableFeatures_st ) ) .
                licensableFeaturesCount as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                nvmlGridLicensableFeatures_st ) , "::" , stringify ! (
                licensableFeaturesCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlGridLicensableFeatures_st ) ) .
                gridLicensableFeatures as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                nvmlGridLicensableFeatures_st ) , "::" , stringify ! (
                gridLicensableFeatures ) ));
}
impl Clone for nvmlGridLicensableFeatures_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlGridLicensableFeatures_t = nvmlGridLicensableFeatures_st;
pub const nvmlEncoderQueryType_enum_NVML_ENCODER_QUERY_H264:
          nvmlEncoderQueryType_enum =
    0;
pub const nvmlEncoderQueryType_enum_NVML_ENCODER_QUERY_HEVC:
          nvmlEncoderQueryType_enum =
    1;
pub type nvmlEncoderQueryType_enum = raw::c_uint;
pub use self::nvmlEncoderQueryType_enum as nvmlEncoderType_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlEncoderSessionInfo_st {
    pub sessionId: raw::c_uint,
    pub pid: raw::c_uint,
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub codecType: nvmlEncoderType_t,
    pub hResolution: raw::c_uint,
    pub vResolution: raw::c_uint,
    pub averageFps: raw::c_uint,
    pub averageLatency: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlEncoderSessionInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlEncoderSessionInfo_st>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( nvmlEncoderSessionInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlEncoderSessionInfo_st>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlEncoderSessionInfo_st )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEncoderSessionInfo_st ) ) . sessionId
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlEncoderSessionInfo_st ) , "::" , stringify ! ( sessionId )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEncoderSessionInfo_st ) ) . pid as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlEncoderSessionInfo_st ) , "::" , stringify ! ( pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEncoderSessionInfo_st ) ) .
                vgpuInstance as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlEncoderSessionInfo_st ) , "::" , stringify ! (
                vgpuInstance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEncoderSessionInfo_st ) ) . codecType
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlEncoderSessionInfo_st ) , "::" , stringify ! ( codecType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEncoderSessionInfo_st ) ) .
                hResolution as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlEncoderSessionInfo_st ) , "::" , stringify ! ( hResolution
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEncoderSessionInfo_st ) ) .
                vResolution as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlEncoderSessionInfo_st ) , "::" , stringify ! ( vResolution
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEncoderSessionInfo_st ) ) .
                averageFps as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlEncoderSessionInfo_st ) , "::" , stringify ! ( averageFps
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEncoderSessionInfo_st ) ) .
                averageLatency as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlEncoderSessionInfo_st ) , "::" , stringify ! (
                averageLatency ) ));
}
impl Clone for nvmlEncoderSessionInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlEncoderSessionInfo_t = nvmlEncoderSessionInfo_st;
extern "C" {
    pub fn nvmlInit_v2() -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlShutdown() -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlErrorString(result: nvmlReturn_t) -> *const raw::c_char;
}
extern "C" {
    pub fn nvmlSystemGetDriverVersion(version: *mut raw::c_char,
                                      length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetNVMLVersion(version: *mut raw::c_char,
                                    length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetCudaDriverVersion(cudaDriverVersion: *mut raw::c_int)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetProcessName(pid: raw::c_uint, name: *mut raw::c_char,
                                    length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetCount(unitCount: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetHandleByIndex(index: raw::c_uint, unit: *mut nvmlUnit_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetUnitInfo(unit: nvmlUnit_t, info: *mut nvmlUnitInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetLedState(unit: nvmlUnit_t, state: *mut nvmlLedState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetPsuInfo(unit: nvmlUnit_t, psu: *mut nvmlPSUInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetTemperature(unit: nvmlUnit_t, type_: raw::c_uint,
                                  temp: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetFanSpeedInfo(unit: nvmlUnit_t,
                                   fanSpeeds: *mut nvmlUnitFanSpeeds_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetDevices(unit: nvmlUnit_t, deviceCount: *mut raw::c_uint,
                              devices: *mut nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetHicVersion(hwbcCount: *mut raw::c_uint,
                                   hwbcEntries: *mut nvmlHwbcEntry_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCount_v2(deviceCount: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleByIndex_v2(index: raw::c_uint,
                                         device: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleBySerial(serial: *const raw::c_char,
                                       device: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleByUUID(uuid: *const raw::c_char,
                                     device: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleByPciBusId_v2(pciBusId: *const raw::c_char,
                                            device: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetName(device: nvmlDevice_t, name: *mut raw::c_char,
                             length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBrand(device: nvmlDevice_t,
                              type_: *mut nvmlBrandType_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetIndex(device: nvmlDevice_t, index: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSerial(device: nvmlDevice_t, serial: *mut raw::c_char,
                               length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCpuAffinity(device: nvmlDevice_t,
                                    cpuSetSize: raw::c_uint,
                                    cpuSet: *mut raw::c_ulong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceClearCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTopologyCommonAncestor(device1: nvmlDevice_t,
                                               device2: nvmlDevice_t,
                                               pathInfo:
                                                   *mut nvmlGpuTopologyLevel_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTopologyNearestGpus(device: nvmlDevice_t,
                                            level: nvmlGpuTopologyLevel_t,
                                            count: *mut raw::c_uint,
                                            deviceArray: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetTopologyGpuSet(cpuNumber: raw::c_uint,
                                       count: *mut raw::c_uint,
                                       deviceArray: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetP2PStatus(device1: nvmlDevice_t,
                                  device2: nvmlDevice_t,
                                  p2pIndex: nvmlGpuP2PCapsIndex_t,
                                  p2pStatus: *mut nvmlGpuP2PStatus_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetUUID(device: nvmlDevice_t, uuid: *mut raw::c_char,
                             length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMinorNumber(device: nvmlDevice_t,
                                    minorNumber: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBoardPartNumber(device: nvmlDevice_t,
                                        partNumber: *mut raw::c_char,
                                        length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetInforomVersion(device: nvmlDevice_t,
                                       object: nvmlInforomObject_t,
                                       version: *mut raw::c_char,
                                       length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetInforomImageVersion(device: nvmlDevice_t,
                                            version: *mut raw::c_char,
                                            length: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetInforomConfigurationChecksum(device: nvmlDevice_t,
                                                     checksum:
                                                         *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceValidateInforom(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDisplayMode(device: nvmlDevice_t,
                                    display: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDisplayActive(device: nvmlDevice_t,
                                      isActive: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPersistenceMode(device: nvmlDevice_t,
                                        mode: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPciInfo_v3(device: nvmlDevice_t,
                                   pci: *mut nvmlPciInfo_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPciInfo_v2(device: nvmlDevice_t,
                                   pci: *mut nvmlPciInfo_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMaxPcieLinkGeneration(device: nvmlDevice_t,
                                              maxLinkGen: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMaxPcieLinkWidth(device: nvmlDevice_t,
                                         maxLinkWidth: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCurrPcieLinkGeneration(device: nvmlDevice_t,
                                               currLinkGen: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCurrPcieLinkWidth(device: nvmlDevice_t,
                                          currLinkWidth: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPcieThroughput(device: nvmlDevice_t,
                                       counter: nvmlPcieUtilCounter_t,
                                       value: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPcieReplayCounter(device: nvmlDevice_t,
                                          value: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetClockInfo(device: nvmlDevice_t,
                                  type_: nvmlClockType_t,
                                  clock: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMaxClockInfo(device: nvmlDevice_t,
                                     type_: nvmlClockType_t,
                                     clock: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetApplicationsClock(device: nvmlDevice_t,
                                          clockType: nvmlClockType_t,
                                          clockMHz: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDefaultApplicationsClock(device: nvmlDevice_t,
                                                 clockType: nvmlClockType_t,
                                                 clockMHz: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceResetApplicationsClocks(device: nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetClock(device: nvmlDevice_t,
                              clockType: nvmlClockType_t,
                              clockId: nvmlClockId_t,
                              clockMHz: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMaxCustomerBoostClock(device: nvmlDevice_t,
                                              clockType: nvmlClockType_t,
                                              clockMHz: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedMemoryClocks(device: nvmlDevice_t,
                                              count: *mut raw::c_uint,
                                              clocksMHz: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedGraphicsClocks(device: nvmlDevice_t,
                                                memoryClockMHz: raw::c_uint,
                                                count: *mut raw::c_uint,
                                                clocksMHz: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAutoBoostedClocksEnabled(device: nvmlDevice_t,
                                                 isEnabled:
                                                     *mut nvmlEnableState_t,
                                                 defaultIsEnabled:
                                                     *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetAutoBoostedClocksEnabled(device: nvmlDevice_t,
                                                 enabled: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetDefaultAutoBoostedClocksEnabled(device: nvmlDevice_t,
                                                        enabled:
                                                            nvmlEnableState_t,
                                                        flags: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetFanSpeed(device: nvmlDevice_t,
                                 speed: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTemperature(device: nvmlDevice_t,
                                    sensorType: nvmlTemperatureSensors_t,
                                    temp: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTemperatureThreshold(device: nvmlDevice_t,
                                             thresholdType:
                                                 nvmlTemperatureThresholds_t,
                                             temp: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPerformanceState(device: nvmlDevice_t,
                                         pState: *mut nvmlPstates_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCurrentClocksThrottleReasons(device: nvmlDevice_t,
                                                     clocksThrottleReasons:
                                                         *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedClocksThrottleReasons(device: nvmlDevice_t,
                                                       supportedClocksThrottleReasons:
                                                           *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerState(device: nvmlDevice_t,
                                   pState: *mut nvmlPstates_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerManagementMode(device: nvmlDevice_t,
                                            mode: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerManagementLimit(device: nvmlDevice_t,
                                             limit: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerManagementLimitConstraints(device: nvmlDevice_t,
                                                        minLimit:
                                                            *mut raw::c_uint,
                                                        maxLimit:
                                                            *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerManagementDefaultLimit(device: nvmlDevice_t,
                                                    defaultLimit:
                                                        *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerUsage(device: nvmlDevice_t,
                                   power: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTotalEnergyConsumption(device: nvmlDevice_t,
                                               energy: *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetEnforcedPowerLimit(device: nvmlDevice_t,
                                           limit: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetGpuOperationMode(device: nvmlDevice_t,
                                         current: *mut nvmlGpuOperationMode_t,
                                         pending: *mut nvmlGpuOperationMode_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMemoryInfo(device: nvmlDevice_t,
                                   memory: *mut nvmlMemory_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetComputeMode(device: nvmlDevice_t,
                                    mode: *mut nvmlComputeMode_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCudaComputeCapability(device: nvmlDevice_t,
                                              major: *mut raw::c_int,
                                              minor: *mut raw::c_int)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetEccMode(device: nvmlDevice_t,
                                current: *mut nvmlEnableState_t,
                                pending: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBoardId(device: nvmlDevice_t,
                                boardId: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMultiGpuBoard(device: nvmlDevice_t,
                                      multiGpuBool: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTotalEccErrors(device: nvmlDevice_t,
                                       errorType: nvmlMemoryErrorType_t,
                                       counterType: nvmlEccCounterType_t,
                                       eccCounts: *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDetailedEccErrors(device: nvmlDevice_t,
                                          errorType: nvmlMemoryErrorType_t,
                                          counterType: nvmlEccCounterType_t,
                                          eccCounts:
                                              *mut nvmlEccErrorCounts_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMemoryErrorCounter(device: nvmlDevice_t,
                                           errorType: nvmlMemoryErrorType_t,
                                           counterType: nvmlEccCounterType_t,
                                           locationType: nvmlMemoryLocation_t,
                                           count: *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetUtilizationRates(device: nvmlDevice_t,
                                         utilization: *mut nvmlUtilization_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetEncoderUtilization(device: nvmlDevice_t,
                                           utilization: *mut raw::c_uint,
                                           samplingPeriodUs: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetEncoderCapacity(device: nvmlDevice_t,
                                        encoderQueryType: nvmlEncoderType_t,
                                        encoderCapacity: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetEncoderStats(device: nvmlDevice_t,
                                     sessionCount: *mut raw::c_uint,
                                     averageFps: *mut raw::c_uint,
                                     averageLatency: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetEncoderSessions(device: nvmlDevice_t,
                                        sessionCount: *mut raw::c_uint,
                                        sessionInfos:
                                            *mut nvmlEncoderSessionInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDecoderUtilization(device: nvmlDevice_t,
                                           utilization: *mut raw::c_uint,
                                           samplingPeriodUs: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDriverModel(device: nvmlDevice_t,
                                    current: *mut nvmlDriverModel_t,
                                    pending: *mut nvmlDriverModel_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetVbiosVersion(device: nvmlDevice_t,
                                     version: *mut raw::c_char,
                                     length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBridgeChipInfo(device: nvmlDevice_t,
                                       bridgeHierarchy:
                                           *mut nvmlBridgeChipHierarchy_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetComputeRunningProcesses(device: nvmlDevice_t,
                                                infoCount: *mut raw::c_uint,
                                                infos: *mut nvmlProcessInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetGraphicsRunningProcesses(device: nvmlDevice_t,
                                                 infoCount: *mut raw::c_uint,
                                                 infos:
                                                     *mut nvmlProcessInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceOnSameBoard(device1: nvmlDevice_t, device2: nvmlDevice_t,
                                 onSameBoard: *mut raw::c_int)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAPIRestriction(device: nvmlDevice_t,
                                       apiType: nvmlRestrictedAPI_t,
                                       isRestricted: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSamples(device: nvmlDevice_t,
                                type_: nvmlSamplingType_t,
                                lastSeenTimeStamp: raw::c_ulonglong,
                                sampleValType: *mut nvmlValueType_t,
                                sampleCount: *mut raw::c_uint,
                                samples: *mut nvmlSample_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBAR1MemoryInfo(device: nvmlDevice_t,
                                       bar1Memory: *mut nvmlBAR1Memory_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetViolationStatus(device: nvmlDevice_t,
                                        perfPolicyType: nvmlPerfPolicyType_t,
                                        violTime: *mut nvmlViolationTime_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAccountingMode(device: nvmlDevice_t,
                                       mode: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAccountingStats(device: nvmlDevice_t,
                                        pid: raw::c_uint,
                                        stats: *mut nvmlAccountingStats_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAccountingPids(device: nvmlDevice_t,
                                       count: *mut raw::c_uint,
                                       pids: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAccountingBufferSize(device: nvmlDevice_t,
                                             bufferSize: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetRetiredPages(device: nvmlDevice_t,
                                     cause: nvmlPageRetirementCause_t,
                                     pageCount: *mut raw::c_uint,
                                     addresses: *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetRetiredPagesPendingStatus(device: nvmlDevice_t,
                                                  isPending:
                                                      *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitSetLedState(unit: nvmlUnit_t, color: nvmlLedColor_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetPersistenceMode(device: nvmlDevice_t,
                                        mode: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetComputeMode(device: nvmlDevice_t,
                                    mode: nvmlComputeMode_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetEccMode(device: nvmlDevice_t, ecc: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceClearEccErrorCounts(device: nvmlDevice_t,
                                         counterType: nvmlEccCounterType_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetDriverModel(device: nvmlDevice_t,
                                    driverModel: nvmlDriverModel_t,
                                    flags: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetApplicationsClocks(device: nvmlDevice_t,
                                           memClockMHz: raw::c_uint,
                                           graphicsClockMHz: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetPowerManagementLimit(device: nvmlDevice_t,
                                             limit: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetGpuOperationMode(device: nvmlDevice_t,
                                         mode: nvmlGpuOperationMode_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetAPIRestriction(device: nvmlDevice_t,
                                       apiType: nvmlRestrictedAPI_t,
                                       isRestricted: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetAccountingMode(device: nvmlDevice_t,
                                       mode: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceClearAccountingPids(device: nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkState(device: nvmlDevice_t, link: raw::c_uint,
                                    isActive: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkVersion(device: nvmlDevice_t, link: raw::c_uint,
                                      version: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkCapability(device: nvmlDevice_t,
                                         link: raw::c_uint,
                                         capability: nvmlNvLinkCapability_t,
                                         capResult: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkRemotePciInfo_v2(device: nvmlDevice_t,
                                               link: raw::c_uint,
                                               pci: *mut nvmlPciInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkErrorCounter(device: nvmlDevice_t,
                                           link: raw::c_uint,
                                           counter: nvmlNvLinkErrorCounter_t,
                                           counterValue:
                                               *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceResetNvLinkErrorCounters(device: nvmlDevice_t,
                                              link: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetNvLinkUtilizationControl(device: nvmlDevice_t,
                                                 link: raw::c_uint,
                                                 counter: raw::c_uint,
                                                 control:
                                                     *mut nvmlNvLinkUtilizationControl_t,
                                                 reset: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkUtilizationControl(device: nvmlDevice_t,
                                                 link: raw::c_uint,
                                                 counter: raw::c_uint,
                                                 control:
                                                     *mut nvmlNvLinkUtilizationControl_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkUtilizationCounter(device: nvmlDevice_t,
                                                 link: raw::c_uint,
                                                 counter: raw::c_uint,
                                                 rxcounter:
                                                     *mut raw::c_ulonglong,
                                                 txcounter:
                                                     *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceFreezeNvLinkUtilizationCounter(device: nvmlDevice_t,
                                                    link: raw::c_uint,
                                                    counter: raw::c_uint,
                                                    freeze: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceResetNvLinkUtilizationCounter(device: nvmlDevice_t,
                                                   link: raw::c_uint,
                                                   counter: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlEventSetCreate(set: *mut nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceRegisterEvents(device: nvmlDevice_t,
                                    eventTypes: raw::c_ulonglong,
                                    set: nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedEventTypes(device: nvmlDevice_t,
                                            eventTypes: *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlEventSetWait(set: nvmlEventSet_t, data: *mut nvmlEventData_t,
                            timeoutms: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlEventSetFree(set: nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceModifyDrainState(pciInfo: *mut nvmlPciInfo_t,
                                      newState: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceQueryDrainState(pciInfo: *mut nvmlPciInfo_t,
                                     currentState: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceRemoveGpu(pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceDiscoverGpus(pciInfo: *mut nvmlPciInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetFieldValues(device: nvmlDevice_t,
                                    valuesCount: raw::c_int,
                                    values: *mut nvmlFieldValue_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetVirtualizationMode(device: nvmlDevice_t,
                                           pVirtualMode:
                                               *mut nvmlGpuVirtualizationMode_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetVirtualizationMode(device: nvmlDevice_t,
                                           virtualMode:
                                               nvmlGpuVirtualizationMode_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedVgpus(device: nvmlDevice_t,
                                       vgpuCount: *mut raw::c_uint,
                                       vgpuTypeIds: *mut nvmlVgpuTypeId_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCreatableVgpus(device: nvmlDevice_t,
                                       vgpuCount: *mut raw::c_uint,
                                       vgpuTypeIds: *mut nvmlVgpuTypeId_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuTypeGetClass(vgpuTypeId: nvmlVgpuTypeId_t,
                                vgpuTypeClass: *mut raw::c_char,
                                size: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuTypeGetName(vgpuTypeId: nvmlVgpuTypeId_t,
                               vgpuTypeName: *mut raw::c_char,
                               size: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuTypeGetDeviceID(vgpuTypeId: nvmlVgpuTypeId_t,
                                   deviceID: *mut raw::c_ulonglong,
                                   subsystemID: *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuTypeGetFramebufferSize(vgpuTypeId: nvmlVgpuTypeId_t,
                                          fbSize: *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuTypeGetNumDisplayHeads(vgpuTypeId: nvmlVgpuTypeId_t,
                                          numDisplayHeads: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuTypeGetResolution(vgpuTypeId: nvmlVgpuTypeId_t,
                                     displayIndex: raw::c_uint,
                                     xdim: *mut raw::c_uint,
                                     ydim: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuTypeGetLicense(vgpuTypeId: nvmlVgpuTypeId_t,
                                  vgpuTypeLicenseString: *mut raw::c_char,
                                  size: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuTypeGetFrameRateLimit(vgpuTypeId: nvmlVgpuTypeId_t,
                                         frameRateLimit: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuTypeGetMaxInstances(device: nvmlDevice_t,
                                       vgpuTypeId: nvmlVgpuTypeId_t,
                                       vgpuInstanceCount: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetActiveVgpus(device: nvmlDevice_t,
                                    vgpuCount: *mut raw::c_uint,
                                    vgpuInstances: *mut nvmlVgpuInstance_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuInstanceGetVmID(vgpuInstance: nvmlVgpuInstance_t,
                                   vmId: *mut raw::c_char, size: raw::c_uint,
                                   vmIdType: *mut nvmlVgpuVmIdType_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuInstanceGetUUID(vgpuInstance: nvmlVgpuInstance_t,
                                   uuid: *mut raw::c_char, size: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuInstanceGetVmDriverVersion(vgpuInstance:
                                                  nvmlVgpuInstance_t,
                                              version: *mut raw::c_char,
                                              length: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuInstanceGetFbUsage(vgpuInstance: nvmlVgpuInstance_t,
                                      fbUsage: *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuInstanceGetLicenseStatus(vgpuInstance: nvmlVgpuInstance_t,
                                            licensed: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuInstanceGetType(vgpuInstance: nvmlVgpuInstance_t,
                                   vgpuTypeId: *mut nvmlVgpuTypeId_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuInstanceGetFrameRateLimit(vgpuInstance: nvmlVgpuInstance_t,
                                             frameRateLimit: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuInstanceGetEncoderCapacity(vgpuInstance:
                                                  nvmlVgpuInstance_t,
                                              encoderCapacity:
                                                  *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuInstanceSetEncoderCapacity(vgpuInstance:
                                                  nvmlVgpuInstance_t,
                                              encoderCapacity: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetVgpuUtilization(device: nvmlDevice_t,
                                        lastSeenTimeStamp: raw::c_ulonglong,
                                        sampleValType: *mut nvmlValueType_t,
                                        vgpuInstanceSamplesCount:
                                            *mut raw::c_uint,
                                        utilizationSamples:
                                            *mut nvmlVgpuInstanceUtilizationSample_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetVgpuProcessUtilization(device: nvmlDevice_t,
                                               lastSeenTimeStamp:
                                                   raw::c_ulonglong,
                                               vgpuProcessSamplesCount:
                                                   *mut raw::c_uint,
                                               utilizationSamples:
                                                   *mut nvmlVgpuProcessUtilizationSample_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetGridLicensableFeatures(device: nvmlDevice_t,
                                               pGridLicensableFeatures:
                                                   *mut nvmlGridLicensableFeatures_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuInstanceGetEncoderStats(vgpuInstance: nvmlVgpuInstance_t,
                                           sessionCount: *mut raw::c_uint,
                                           averageFps: *mut raw::c_uint,
                                           averageLatency: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlVgpuInstanceGetEncoderSessions(vgpuInstance:
                                                  nvmlVgpuInstance_t,
                                              sessionCount: *mut raw::c_uint,
                                              sessionInfo:
                                                  *mut nvmlEncoderSessionInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetProcessUtilization(device: nvmlDevice_t,
                                           utilization:
                                               *mut nvmlProcessUtilizationSample_t,
                                           processSamplesCount:
                                               *mut raw::c_uint,
                                           lastSeenTimeStamp:
                                               raw::c_ulonglong)
     -> nvmlReturn_t;
}
